import Vuex from 'vuex';

function createDirectStore(options) {
    const original = new Vuex.Store(options);
    const store = {
        get state() {
            return original.state;
        },
        getters: toDirectGetters(options, original.getters),
        commit: toDirectCommit(options, original.commit),
        dispatch: toDirectDispatch(options, original.dispatch),
        original
    };
    original.direct = store;
    return {
        store,
        rootGetterContext: ([state, getters]) => getModuleGetterContext([state, getters, state, getters], options, options),
        moduleGetterContext: (args, moduleOptions) => getModuleGetterContext(args, moduleOptions, options),
        rootActionContext: (originalContext) => getModuleActionContext(originalContext, options, options),
        moduleActionContext: (originalContext, moduleOptions) => getModuleActionContext(originalContext, moduleOptions, options),
    };
}
function localGetterContext([state, getters], options) {
    return getModuleGetterContext([state, getters, undefined, undefined], options);
}
function localActionContext(originalContext, options) {
    return getModuleActionContext(originalContext, options);
}
function defineModule(options) {
    return options;
}
function defineModules() {
    return modules => modules;
}
function defineGetters() {
    return getters => getters;
}
function defineMutations() {
    return mutations => mutations;
}
function defineActions(actions) {
    return actions;
}
const createModule = obsolete(defineModule, "createModule", "defineModule");
const createModules = obsolete(defineModules, "createModules", "defineModules");
const createGetters = obsolete(defineGetters, "createGetters", "defineGetters");
const createMutations = obsolete(defineMutations, "createMutations", "defineMutations");
const createActions = obsolete(defineActions, "createActions", "defineActions");
function obsolete(fn, oldName, newName) {
    return ((...args) => {
        // tslint:disable-next-line:no-console
        console.warn(`Function '${oldName}' is obsolete, please use '${newName}'.`);
        return fn(...args);
    });
}
var directVuex = {
    createDirectStore, defineModule, defineModules, defineGetters, defineMutations, defineActions,
    localGetterContext, localActionContext,
    createModule, createModules, createGetters, createMutations, createActions
};
// Getters
const gettersCache = new WeakMap();
function toDirectGetters(options, originalGetters) {
    let getters = gettersCache.get(originalGetters);
    // console.log(">> to-getters", getters ? "FROM_CACHE" : "CREATE", options)
    if (!getters) {
        getters = gettersFromOptions({}, options, originalGetters);
        gettersCache.set(originalGetters, getters);
    }
    return getters;
}
function gettersFromOptions(result, options, originalGetters, hierarchy = []) {
    if (options.getters)
        createDirectGetters(result, options.getters, originalGetters, hierarchy);
    if (options.modules) {
        for (const moduleName of Object.keys(options.modules)) {
            const moduleOptions = options.modules[moduleName];
            if (moduleOptions.namespaced)
                result[moduleName] = gettersFromOptions({}, moduleOptions, originalGetters, [...hierarchy, moduleName]);
            else
                gettersFromOptions(result, moduleOptions, originalGetters, hierarchy);
        }
    }
    return result;
}
function createDirectGetters(result, gettersImpl, originalGetters, hierarchy) {
    const prefix = !hierarchy || hierarchy.length === 0 ? "" : `${hierarchy.join("/")}/`;
    for (const name of Object.keys(gettersImpl)) {
        Object.defineProperties(result, {
            [name]: {
                get: () => originalGetters[`${prefix}${name}`]
            }
        });
    }
}
// Mutations
const commitCache = new WeakMap();
function toDirectCommit(options, originalCommit) {
    let commit = commitCache.get(originalCommit);
    // console.log(">> to-commit", commit ? "FROM_CACHE" : "CREATE", options)
    if (!commit) {
        commit = commitFromOptions({}, options, originalCommit);
        commitCache.set(originalCommit, commit);
    }
    return commit;
}
const rootCommitCache = new WeakMap();
function toDirectRootCommit(rootOptions, originalCommit) {
    let commit = rootCommitCache.get(originalCommit);
    // console.log(">> to-rootCommit", commit ? "FROM_CACHE" : "CREATE", rootOptions)
    if (!commit) {
        const origCall = (mutation, payload) => originalCommit(mutation, payload, { root: true });
        commit = commitFromOptions({}, rootOptions, origCall);
        rootCommitCache.set(originalCommit, commit);
    }
    return commit;
}
function commitFromOptions(result, options, originalCommitCall, hierarchy = []) {
    if (options.mutations)
        createDirectMutations(result, options.mutations, originalCommitCall, hierarchy);
    if (options.modules) {
        for (const moduleName of Object.keys(options.modules)) {
            const moduleOptions = options.modules[moduleName];
            if (moduleOptions.namespaced)
                result[moduleName] = commitFromOptions({}, moduleOptions, originalCommitCall, [...hierarchy, moduleName]);
            else
                commitFromOptions(result, moduleOptions, originalCommitCall, hierarchy);
        }
    }
    return result;
}
function createDirectMutations(result, mutationsImpl, originalCommitCall, hierarchy) {
    const prefix = !hierarchy || hierarchy.length === 0 ? "" : `${hierarchy.join("/")}/`;
    for (const name of Object.keys(mutationsImpl))
        result[name] = (payload) => originalCommitCall(`${prefix}${name}`, payload);
}
// Actions
const dispatchCache = new WeakMap();
function toDirectDispatch(options, originalDispatch) {
    let dispatch = dispatchCache.get(originalDispatch);
    // console.log(">> to-dispatch", dispatch ? "FROM_CACHE" : "CREATE", options)
    if (!dispatch) {
        dispatch = dispatchFromOptions({}, options, originalDispatch);
        dispatchCache.set(originalDispatch, dispatch);
    }
    return dispatch;
}
const rootDispatchCache = new WeakMap();
function toDirectRootDispatch(rootOptions, originalDispatch) {
    let dispatch = rootDispatchCache.get(originalDispatch);
    // console.log(">> to-rootDispatch", dispatch ? "FROM_CACHE" : "CREATE", rootOptions)
    if (!dispatch) {
        const origCall = (mutation, payload) => originalDispatch(mutation, payload, { root: true });
        dispatch = dispatchFromOptions({}, rootOptions, origCall);
        rootDispatchCache.set(originalDispatch, dispatch);
    }
    return dispatch;
}
function dispatchFromOptions(result, options, originalDispatchCall, hierarchy = []) {
    if (options.actions)
        createDirectActions(result, options.actions, originalDispatchCall, hierarchy);
    if (options.modules) {
        for (const moduleName of Object.keys(options.modules)) {
            const moduleOptions = options.modules[moduleName];
            if (moduleOptions.namespaced)
                result[moduleName] = dispatchFromOptions({}, moduleOptions, originalDispatchCall, [...hierarchy, moduleName]);
            else
                dispatchFromOptions(result, moduleOptions, originalDispatchCall, hierarchy);
        }
    }
    return result;
}
function createDirectActions(result, actionsImpl, originalDispatchCall, hierarchy) {
    const prefix = !hierarchy || hierarchy.length === 0 ? "" : `${hierarchy.join("/")}/`;
    for (const name of Object.keys(actionsImpl))
        result[name] = (payload) => originalDispatchCall(`${prefix}${name}`, payload);
}
// GetterContext
const getterContextCache = new WeakMap();
function getModuleGetterContext(args, options, rootOptions) {
    const [state, getters, rootState, rootGetters] = args;
    let context = actionContextCache.get(state);
    // console.log(">> to-getterContext", context ? "FROM_CACHE" : "CREATE", options)
    if (!context) {
        if (rootOptions) {
            context = {
                get rootState() {
                    return rootState;
                },
                get rootGetters() {
                    return toDirectGetters(rootOptions, rootGetters);
                },
                get state() {
                    return state;
                },
                get getters() {
                    return toDirectGetters(options, getters);
                }
            };
        }
        else {
            context = {
                get state() {
                    return state;
                },
                get getters() {
                    return toDirectGetters(options, getters);
                }
            };
        }
        if (state) // Can be undefined in unit tests
            getterContextCache.set(state, context);
    }
    return context;
}
// ActionContext
const actionContextCache = new WeakMap();
function getModuleActionContext(originalContext, options, rootOptions) {
    let context = actionContextCache.get(originalContext.state);
    // console.log(">> to-actionContext", context ? "FROM_CACHE" : "CREATE", options)
    if (!context) {
        if (rootOptions) {
            context = {
                get rootState() {
                    return originalContext.rootState;
                },
                get rootGetters() {
                    return toDirectGetters(rootOptions, originalContext.rootGetters);
                },
                get rootCommit() {
                    return toDirectRootCommit(rootOptions, originalContext.commit);
                },
                get rootDispatch() {
                    return toDirectRootDispatch(rootOptions, originalContext.dispatch);
                },
                get state() {
                    return originalContext.state;
                },
                get getters() {
                    return toDirectGetters(options, originalContext.getters);
                },
                get commit() {
                    return toDirectCommit(options, originalContext.commit);
                },
                get dispatch() {
                    return toDirectDispatch(options, originalContext.dispatch);
                }
            };
        }
        else {
            context = {
                get state() {
                    return originalContext.state;
                },
                get getters() {
                    return toDirectGetters(options, originalContext.getters);
                },
                get commit() {
                    return toDirectCommit(options, originalContext.commit);
                },
                get dispatch() {
                    return toDirectDispatch(options, originalContext.dispatch);
                }
            };
        }
        if (originalContext.state) // Can be undefined in unit tests
            actionContextCache.set(originalContext.state, context);
    }
    return context;
}

export default directVuex;
export { createActions, createDirectStore, createGetters, createModule, createModules, createMutations, defineActions, defineGetters, defineModule, defineModules, defineMutations, localActionContext, localGetterContext };
